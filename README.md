# UserDBManager - это Python-скрипт, который предоставляет функциональность управления данными пользователей с использованием базы данных SQLite - легковесного, безсерверного движка баз данных. Скрипт реализует класс UserDatabase, который включает методы для создания таблицы пользователей, добавления пользователей, получения списка всех пользователей, обновления информации о пользователе и удаления пользователей из базы данных.

## Требования
- Python 3.x
- SQLite (включен в Python)
## Использование
1. Импортируйте необходимые модули:
- import sqlite3
- import logging  

2. Создайте экземпляр класса UserDatabase, указав имя файла базы данных (по умолчанию 'users.db'):
- with UserDatabase() as db:

## Выполните операции с базой данных...

### Функциональность
- __init__(self, db_name='users.db')
Конструктор инициализирует объект UserDatabase с опциональным именем файла базы данных. Если имя не указано, будет использовано имя 'users.db'. Соединение и курсор устанавливаются в значение None.

- __enter__(self)
Метод используется для установки соединения с базой данных SQLite при использовании оператора with. Он возвращает объект UserDatabase, что позволяет выполнять операции с базой данных.

- __exit__(self, exc_type, exc_value, traceback)
Этот метод автоматически вызывается по окончании блока with. Он обеспечивает сохранение изменений в базе данных и корректное закрытие соединения.

- create_table(self)
Создает таблицу 'users', если она еще не существует. Таблица 'users' содержит четыре столбца: id, name, age и email. Поле id является первичным ключом, обеспечивая уникальность идентификаторов для каждого пользователя.

- add_user(self, name, age, email)
Добавляет нового пользователя в таблицу 'users' с указанными именем, возрастом и адресом электронной почты. В случае успешного добавления, происходит логгирование этой операции и имени пользователя.

- get_all_users(self)
Получает всех пользователей из таблицы 'users' и возвращает их в виде списка кортежей (id, name, age, email). В случае ошибки при получении данных, возвращается пустой список.

- update_user(self, user_id, name, age, email)
Обновляет информацию о существующем пользователе с указанным идентификатором user_id. Меняет значения имени, возраста и адреса электронной почты для пользователя с соответствующим идентификатором. В случае успешного обновления, происходит логгирование этой операции и идентификатора пользователя.

- delete_user(self, user_id)
Удаляет пользователя с указанным идентификатором user_id из таблицы 'users'. В случае успешного удаления, происходит логгирование этой операции и идентификатора пользователя.

### Пример
В предоставленном примере показано, как использовать класс UserDatabase для выполнения основных операций управления пользователями:

- Создается таблица 'users', если она не существует.
- Добавляются два пользователя в базу данных.
- Получаются и выводятся на экран все пользователи.
- Обновляются данные для пользователя с идентификатором 1.
- Получается и выводится на экран обновленный пользователь.
- Удаляется пользователь с идентификатором 2.
- Получаются и выводятся на экран все пользователи после удаления.
Обратите внимание, что данный пример предназначен только для демонстрации и не обрабатывает исключения или проверяет ввод пользователя.

### Эффективность
Эффективность данного кода зависит от различных факторов, таких как 
- размер таблицы 'users', 
- сложность запросов и используемое оборудование для работы с SQLite. 

SQLite обычно хорошо подходит для небольших и средних приложений с умеренной нагрузкой.

Для простых операций CRUD (создание, чтение, обновление и удаление) над небольшими наборами данных SQLite показывает хорошую производительность и скорость. Однако, если приложение рассчитано на обработку большого числа пользователей и сложных запросов, более масштабируемое решение, такое как PostgreSQL, MySQL или NoSQL базы данных, может быть предпочтительнее.

Оптимизация структуры таблицы, использование индексов и избегание лишних запросов помогут повысить производительность базы данных. Также следует учитывать, что SQLite обрабатывает только одну операцию записи за раз, что может быть узким местом при высокой конкуренции записей. В случае высокой конкуренции стоит рассмотреть базы данных с более высокой поддержкой параллельной записи.

При разработке критических или продукционных приложений рекомендуется провести тестирование производительности и бенчмаркинг для определения соответствия SQLite конкретным требованиям проекта.

### Запуск
- склонировать репозиторий:
``` bash
git clone git@github.com:Aliaksandr-Litvinau/user-db-manager.git
```
- запуск выполнения скрипта db.py:
``` bash
python3 db.py
```